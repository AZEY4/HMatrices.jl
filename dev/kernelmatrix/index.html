<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kernel matrices · HMatrices.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://WaveProp.github.io/HMatrices.jl/kernelmatrix/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HMatrices.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li class="is-active"><a class="tocitem" href>Kernel matrices</a><ul class="internal"><li><a class="tocitem" href="#Support-for-tensor-kernels"><span>Support for tensor kernels</span></a></li><li><a class="tocitem" href="#Vectorized-kernels-and-local-indices"><span>Vectorized kernels and local indices</span></a></li></ul></li><li><a class="tocitem" href="../dhmatrix/">Distributed HMatrix</a></li><li><a class="tocitem" href="../notebooks/">Notebooks</a></li><li><a class="tocitem" href="../benchs/">Benchmarks</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Kernel matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kernel matrices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/HMatrices.jl/blob/master/docs/src/kernelmatrix.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="kernelmatrix-section"><a class="docs-heading-anchor" href="#kernelmatrix-section">Kernel matrices</a><a id="kernelmatrix-section-1"></a><a class="docs-heading-anchor-permalink" href="#kernelmatrix-section" title="Permalink"></a></h1><p>While in the <a href="../#assemble-generic-subsection">introduction</a> we presented a somewhat general way to assemble an <code>HMatrix</code>, abstract matrices associated with an underlying kernel function are common enough in boundary integral equations that a special interface exists for facilitating their use.</p><p>The <a href="../references/#HMatrices.AbstractKernelMatrix"><code>AbstractKernelMatrix</code></a> interface is used to represent matrices <code>K</code> with <code>i,j</code> entry given by <code>f(X[i],Y[j])</code>, where <code>X=rowelements(K)</code> and <code>Y=colelements(K)</code>. The row and columns elements may be as simple as points in <span>$\mathbb{R}^d$</span> (as is the case for Nyström methods), but they can also be more complex objects such as triangles or basis functions –- the only thing required is that <code>f(X[i],Y[j])</code> make sense. </p><p>A concrete implementation of <code>AbstractKernelMatrix</code> is provided by the <code>KernelMatrix</code> type. Creating the matrix associated with the Helmholtz free-space Greens function, for example, can be accomplished through:</p><pre><code class="language-julia hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point3D = SVector{3,Float64}
X = rand(Point3D,10_000)
Y = rand(Point3D,10_000)
const k = 2π
function G(x,y)
    d = norm(x-y)
    exp(im*k*d)/(4π*d)
end
K = KernelMatrix(G,X,Y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000×10000 KernelMatrix{typeof(Main.G), Vector{StaticArrays.SVector{3, Float64}}, Vector{StaticArrays.SVector{3, Float64}}, ComplexF64}:
  0.0410175+0.342034im     0.0237271+0.0623912im  …   -0.167218+0.081346im
 -0.0176238-0.108437im    -0.0142072-0.108198im       -0.116017-0.0702742im
  0.0440391-0.0857503im    -0.166363+0.0888565im      -0.165073+0.0239323im
  0.0251385-0.0975239im    0.0776503-0.0355988im      0.0012599-0.105828im
   -0.16725+0.0395941im    0.0745359-0.0451114im      -0.168174+0.0542833im
   0.079005-0.0297259im    -0.166848+0.0358835im  …  -0.0594791-0.103435im
  0.0172699-0.100954im     -0.110479-0.075294im       -0.145899+0.159787im
  0.0781726-0.0335424im    -0.147154-0.0287694im      -0.150739-0.0215518im
   0.057315-0.0732375im    -0.120352-0.0659731im      -0.167257+0.0396664im
 -0.0448195-0.10685im      -0.030381-0.108456im       -0.129663+0.190752im
           ⋮                                      ⋱  
  0.0594465-0.0707377im   -0.0555751-0.104523im       -0.165572+0.02683im
  -0.164126+0.0190265im    0.0772537-0.0370373im      -0.163031+0.0140599im
  -0.100652-0.0830575im    0.0249232+0.0620989im     -0.0793049-0.0957826im
    -0.1119-0.074054im      0.056894+0.0441483im       -0.06726-0.100865im
 -0.0588937-0.103606im    -0.0718849-0.0990764im  …   -0.167682+0.0758693im
  0.0773893+0.00982214im   -0.160444+0.118885im       -0.102634-0.0815999im
  0.0795194-0.0268312im    -0.035226-0.108109im      0.00845943-0.103963im
  -0.166061+0.0299542im   0.00442844-0.10507im        -0.109848+0.219904im
 -0.0273405-0.108575im     0.0601493-0.0698748im      -0.128487-0.0568799im</code></pre><p>Compressing <code>K</code> is now as simple as:</p><pre><code class="language-julia hljs">H = assemble_hmat(K;rtol=1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HMatrix of ComplexF64 with range 1:10000 × 1:10000
	 number of nodes in tree: 16665
	 number of leaves: 12499 (2459 admissible + 10040 full)
	 min rank of sparse blocks : 22
	 max rank of sparse blocks : 75
	 min length of dense blocks : 1521
	 max length of dense blocks : 1600
	 min number of elements per leaf: 1521
	 max number of elements per leaf: 390625
	 depth of tree: 8
	 compression ratio: 2.392503
</code></pre><p>It is worth noting that several <em>default</em> choices are made during the compression above. See the <a href="../#assemble-generic-subsection">Assembling and <code>HMatrix</code></a> section or the documentation of <a href="../references/#HMatrices.assemble_hmat-Tuple{Any, Any, Any}"><code>assemble_hmat</code></a> for information on how to obtain a more granular control of the assembling stage.</p><p>As before, you can multiply <code>H</code> by a vector, or do an <code>lu</code> factorization of it.</p><h2 id="Support-for-tensor-kernels"><a class="docs-heading-anchor" href="#Support-for-tensor-kernels">Support for tensor kernels</a><a id="Support-for-tensor-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Support-for-tensor-kernels" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Support for tensor-valued kernels should be considered experimental at this stage.</p></div></div><p>For vector-valued partial differential equations such as <em>Stokes</em> or time-harmonic <em>Maxwell&#39;s</em> equation, the underlying integral operator has a kernel function which is a tensor. This package currently provides some limited support for these types of operators. The example below illustrates how to build an <a href="../references/#HMatrices.HMatrix"><code>HMatrix</code></a> representing a <a href="../references/#HMatrices.KernelMatrix"><code>KernelMatrix</code></a> corresponding to Stokes Greens function for points on a sphere:</p><pre><code class="language-julia hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point3D = SVector{3,Float64}
m = 5_000
X = Y = [Point3D(sin(θ)cos(ϕ),sin(θ)*sin(ϕ),cos(θ)) for (θ,ϕ) in zip(π*rand(m),2π*rand(m))]
const μ = 5
function G(x,y)
    r = x-y
    d = norm(r) + 1e-10
    1/(8π*μ) * (1/d*I + r*transpose(r)/d^3)
end
K = KernelMatrix(G,X,Y)
H = assemble_hmat(K;atol=1e-4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HMatrix of StaticArrays.SMatrix{3, 3, Float64, 9} with range 1:5000 × 1:5000
	 number of nodes in tree: 4725
	 number of leaves: 3544 (1200 admissible + 2344 full)
	 min rank of sparse blocks : 7
	 max rank of sparse blocks : 23
	 min length of dense blocks : 1521
	 max length of dense blocks : 1600
	 min number of elements per leaf: 1521
	 max number of elements per leaf: 97969
	 depth of tree: 7
	 compression ratio: 3.482136
</code></pre><p>You can now multiply <code>H</code> by a density <code>σ</code>, where <code>σ</code> is a <code>Vector</code> of <code>SVector{3,Float64}</code></p><pre><code class="language-julia hljs">σ = rand(SVector{3,Float64},m)
y = H*σ
# test the output agains the exact value for a given `i`
i = 42
y[i] - sum(K[i,j]*σ[j] for j in 1:m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):
  0.6020569633692503
 -0.8153557330369949
 -0.018420957028865814</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <em>naive</em> idea of reinterpreting these <em>matrices of tensors</em> as a (larger) matrix of scalars does not always work because care to be taken when choosing the pivot in the compression stage of the <a href="../references/#HMatrices.PartialACA"><code>PartialACA</code></a> in order to exploit some analytic properties of the underlying kernel. See e.g. section 2.3 of <a href="https://www.sciencedirect.com/science/article/pii/S0021999117306721">this paper</a> for a brief discussion.</p></div></div><h2 id="Vectorized-kernels-and-local-indices"><a class="docs-heading-anchor" href="#Vectorized-kernels-and-local-indices">Vectorized kernels and local indices</a><a id="Vectorized-kernels-and-local-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-kernels-and-local-indices" title="Permalink"></a></h2><p>A more efficient implementation of your kernel <code>K::AbstractKernelMatrix</code> can sometimes lead to faster <em>assembling</em> times. In particular, providing a permuted kernel <code>Kp</code> using the local indexing system of the <code>HMatrix</code> (and setting the keyword argument <code>global_index=false</code> in <code>assemble_hmat</code>) avoids frequent unnecessary index permutations, and can facilitate vectorization. This is because the permuted kernel <code>Kp</code> will be called through <code>Kp[I::UnitRange,J::UnitRange]</code> to fill in the dense blocks of the matrix, through <code>Kp[I::UnitRange,j::int]</code> and <code>adjoint(Kp)[I::UnitRange,j]</code> to build a low-rank approximation of compressible blocks. </p><p>The vectorization example in the <a href="../notebooks/#notebook-section">Notebook section</a> shows how a custom (and somewhat more complex) implementation of a vectorized Laplace kernel using the <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization</a> package can lead to faster (sequential) execution.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting started</a><a class="docs-footer-nextpage" href="../dhmatrix/">Distributed HMatrix »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 1 June 2022 14:25">Wednesday 1 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
