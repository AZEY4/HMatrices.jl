<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · HMatrices.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://WaveProp.github.io/HMatrices.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>HMatrices.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#assemble-generic-subsection"><span>Assembling an <code>HMatrix</code></span></a></li><li><a class="tocitem" href="#Matrix-vector-product-and-iterative-solvers"><span>Matrix vector product and iterative solvers</span></a></li><li><a class="tocitem" href="#Factorization-and-direct-solvers"><span>Factorization and direct solvers</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="kernelmatrix/">Kernel matrices</a></li><li><a class="tocitem" href="dhmatrix/">Distributed HMatrix</a></li><li><a class="tocitem" href="notebooks/">Notebooks</a></li><li><a class="tocitem" href="benchs/">Benchmarks</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/HMatrices.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="home-section"><a class="docs-heading-anchor" href="#home-section">HMatrices.jl</a><a id="home-section-1"></a><a class="docs-heading-anchor-permalink" href="#home-section" title="Permalink"></a></h1><p><em>A package for assembling and factoring hierarchical matrices</em></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This package provides some functionality for assembling as well as for doing linear algebra with <a href="https://en.wikipedia.org/wiki/Hierarchical_matrix">hierarchical matrices</a>. The main structure exported is the <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a> type, which can be used to efficiently approximate certain linear operators containing a hierarchical low-rank structure. Once assembled, a hierarchical matrix can be used to accelerate the solution of <code>Ax=b</code> in a variety of ways. Below you will find a quick introduction for how to <em>assemble</em> and <em>utilize</em> an <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a>; see the <a href="references/#references-section">References</a> section for more information on the available methods and structures.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Although hierarchical matrices have a broad range of application, this package focuses on their use to approximate integral operators arising in <strong>boundary integral equation (BIE)</strong> methods. As such, most of the API has been designed with BIEs in mind, and the examples that follow will focus on the compression of integral operators. Feel free to open an <a href="https://github.com/WaveProp/HMatrices.jl/issues/new">issue</a> or reach out if you have an interesting application of hierarchical matrices in mind not covered by this package!</p></div></div><div class="admonition is-success"><header class="admonition-header">Useful references</header><div class="admonition-body"><p>The notation and algorithms implemented were mostly drawn from the following references:</p><ul><li>Hackbusch, Wolfgang. <em>Hierarchical matrices: algorithms and analysis</em>. Vol. 49. Heidelberg: Springer, 2015.</li><li>Bebendorf, Mario. <em>Hierarchical matrices</em>. Springer Berlin Heidelberg,</li></ul><ol><li></li></ol></div></div><h2 id="assemble-generic-subsection"><a class="docs-heading-anchor" href="#assemble-generic-subsection">Assembling an <code>HMatrix</code></a><a id="assemble-generic-subsection-1"></a><a class="docs-heading-anchor-permalink" href="#assemble-generic-subsection" title="Permalink"></a></h2><p>In order to assemble an <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a>, you need the following (problem-specific) ingredients:</p><ol><li>The matrix-like object <code>K</code> that you wish to compress</li><li>A <code>rowtree</code> and <code>coltree</code> providing a hierarchical partition of the rows and columns of <code>K</code></li><li>An admissibility condition for determining (<em>a priory</em>) whether a block given by a node in the <code>rowtree</code> and node in the <code>coltree</code> is compressible</li><li>A function/functor to generate a low-rank approximation of compressible blocks</li></ol><p>To illustrate how this is done for a concrete problem, consider two set of points <span>$X = \left\{ \boldsymbol{x}_i \right\}_{i=1}^m$</span> and <span>$Y =\left\{\boldsymbol{x}_j \right\}_{j=1}^n$</span> in <span>$\mathbb{R}^3$</span>, and let <code>K</code> be a  <span>$m \times n$</span> matrix with entries given by:</p><p class="math-container">\[  K_{i,j} = G(\boldsymbol{x}_i,\boldsymbol{y}_j)\]</p><p>for some kernel function <span>$G$</span>. To make things simple, we will take <span>$X$</span> and <span>$Y$</span> to be points distributed on a circle:</p><pre><code class="language- hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point2D = SVector{2,Float64}

# points on a circle
m = n = 10_000
X = Y = [Point2D(sin(i*2π/n),cos(i*2π/n)) for i in 0:n-1]
nothing</code></pre><p>Next we will create the matrix-like structure to represent the object <code>K</code>. We will pick <code>G</code> to be the free-space Greens function for Laplace&#39;s equation in two-dimensions:</p><pre><code class="language- hljs">struct LaplaceMatrix &lt;: AbstractMatrix{Float64}
  X::Vector{Point2D}  
  Y::Vector{Point2D}
end

Base.getindex(K::LaplaceMatrix,i::Int,j::Int) = -1/2π*log(norm(K.X[i] - K.Y[j]) + 1e-10)
Base.size(K::LaplaceMatrix) = length(K.X), length(K.Y)

# create the abstract matrix
K = LaplaceMatrix(X,Y)</code></pre><p>The next step consists in partitioning the point clouds <code>X</code> and <code>Y</code> into a tree-like data structure so that blocks corresponding to well-separated points can be easily distinguished and compressed. The <code>WavePropBase</code> package provides the <code>ClusterTree</code> struct for this purpose (see its documentation for more details on available options):</p><pre><code class="language- hljs">Xclt = Yclt = ClusterTree(X)
nothing # hide</code></pre><p>The object <code>Xclt</code> represents a tree partition of the point cloud into axis-aligned bounding boxes.</p><p>The third requirement is an <em>admissibilty condition</em> to determine if the interaction between two clusters should be compressed. We will use the <a href="references/#HMatrices.StrongAdmissibilityStd"><code>StrongAdmissibilityStd</code></a>, which is appropriate for <em>asymptotically smooth kernels</em> such as the one considered:</p><pre><code class="language-julia hljs">adm = StrongAdmissibilityStd()</code></pre><p>The final step is to provide a method to compress admissible blocks. Here we will use the <a href="references/#HMatrices.PartialACA"><code>PartialACA</code></a> functor implementing an <em>adaptive cross approximation</em> with partial pivoting strategy:</p><pre><code class="language-julia hljs">comp = PartialACA(;atol=1e-6)</code></pre><p>With these ingredients at hand, we can assemble an approximation for <code>K</code> using</p><pre><code class="language- hljs">H = assemble_hmat(K,Xclt,Yclt;adm,comp,threads=false,distributed=false)</code></pre><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>The <a href="references/#HMatrices.assemble_hmat-Tuple{Any, Any, Any}"><code>assemble_hmat</code></a> function is the main constructor exported by this package, so it is worth getting familiar with it and the various keyword arguments it accepts.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Reasonable defaults exist for the <em>admissibility condition</em>, <em>cluster tree</em>, and <em>compressor</em> when the kernel <code>K</code> is an <a href="references/#HMatrices.AbstractKernelMatrix"><code>AbstractKernelMatrix</code></a>, so that the construction process is somewhat simpler than just presented in those cases. Manually constructing each ingredient, however, gives a level of control not available through the default constructors. See the <a href="kernelmatrix/#kernelmatrix-section">Kernel matrices section</a> for more details.</p></div></div><p>You can now use <code>H</code> <em>in lieu</em> of <code>K</code> (as an approximation) for certain linear algebra operations, as shown next.</p><div class="admonition is-success"><header class="admonition-header">Disabling `getindex`</header><div class="admonition-body"><p>Although the <code>getindex(H,i::Int,j::Int)</code> method is defined for an <code>AbstractHMatrix</code>, its use is mostly for display purposes in a <code>REPL</code> environment, and should be avoided in any linear algebra routine. To avoid the performance pitfalls related to methods falling back to the generic <code>LinearAlgebra</code> implementation of various algorithms (which make use <code>getindex</code> extensively), you can disable <code>getindex</code> on types defined in this package by calling <a href="references/#HMatrices.disable_getindex-Tuple{}"><code>HMatrices.disable_getindex</code></a>. The consequence is that calling <code>getindex(H,i,j)</code> will throw an error. If a given operation is running unexpectedly slow, try disabling <code>getindex</code> to see if any part of the code is falling back to a generic implementation.</p></div></div><h2 id="Matrix-vector-product-and-iterative-solvers"><a class="docs-heading-anchor" href="#Matrix-vector-product-and-iterative-solvers">Matrix vector product and iterative solvers</a><a id="Matrix-vector-product-and-iterative-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-vector-product-and-iterative-solvers" title="Permalink"></a></h2><p>The simplest operation you can perform with an <code>HMatrix</code> is to multiply it by a vector:</p><pre><code class="language- hljs">x = rand(n)
norm(H*x - K*x)</code></pre><p>More advanced options (such as choosing between a threaded or serial implementation) can be accessed by calling <a href="references/#LinearAlgebra.mul!"><code>mul!</code></a> directly:</p><pre><code class="language- hljs">y = similar(x)
mul!(y,H,x,1,0;threads=false,global_index=true)
norm(H*x - K*x)</code></pre><div class="admonition is-category-important"><header class="admonition-header">Local and global indices</header><div class="admonition-body"><p>The hierarchical matrix <code>H</code> above is stored as <code>H = Pr*_H*Pc</code>, where <code>Pr</code> and <code>Pc</code> are row and column permutation matrices, respectively. It is sometimes convenient to work directly with <code>_H</code> for performance reasons (for example, in an iterative solver, you may want to permute rows and columns only once <em>offline</em> and perform the matrix multiplication with <code>_H</code>); the keyword argument <code>global_index=false</code> can be passed to perform the desired operations on <code>_H</code> instead.</p></div></div><div class="admonition is-info"><header class="admonition-header">Problem size</header><div class="admonition-body"><p>For &quot;small&quot; problem sizes, the overhead associated to the more complex structure of the <code>HMatrix</code> will lead to computational times that are larger than the <em>dense</em> representation, even when the <code>HMatrix</code> occupies less memory. For large problem sizes, however, the linear complexity will yield significant gains in terms of memory and cpu time provided the underlying operator has a hierarchical low-rank structure.</p></div></div><h2 id="Factorization-and-direct-solvers"><a class="docs-heading-anchor" href="#Factorization-and-direct-solvers">Factorization and direct solvers</a><a id="Factorization-and-direct-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization-and-direct-solvers" title="Permalink"></a></h2><p>Although the forward map illustrated in the example above suffices to solve the linear system <code>Kx = b</code> using an iterative solver, there are circumstances where a <em>direct</em> solver is desirable (because, e.g., the system is not well-conditioned or you wish to solve it for many right-hand-sides <code>b</code>). At present, the only available factorization is the <strong>hierarchical lu</strong> factorization of <code>H</code>, which can be accomplished as follows:</p><pre><code class="language- hljs">F = lu(H;atol=1e-6)</code></pre><p>Note that unliked the matrix-vector product, factoring <code>H</code> is not <em>exact</em> in the sense that <code>lu(H) ≠ lu(Matrix(H))</code>. The accuracy of the approximation can be controlled through the keyword arguments <code>atol,rol</code> and <code>rank</code>, which are used in the various intermediate truncations performed during the factorization. See <a href="references/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any, N} where N}"><code>lu</code></a> for more details.</p><div class="admonition is-category-important"><header class="admonition-header">Truncation error</header><div class="admonition-body"><p>The parameters <code>atol</code> and <code>rtol</code> are used to control the truncation of low-rank blocks <em>adaptively</em> using an estimate of the true error (in Frobenius norm). These local error may accumulate after successive truncations, which in practice means that the final errors can be somewhat larger than the prescribed tolerance. Because of this, you may want to set <code>atol</code> and <code>rtol</code> to be somewhat smaller than your target accuracy.</p></div></div><p>The returned object <code>F</code> is of the <code>LU</code> type, and efficient routines are provided to solve linear system using <code>F</code>:</p><pre><code class="language- hljs">b = rand(m)
approx = F\b
exact  = Matrix(K)\b
norm(approx-exact)/norm(exact)</code></pre><p>Note that the error in solving the linear system may be significantly larger than the error in computing <code>H*x</code> due to the condition of the underlying operator.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Because factoring an <code>HMatrix</code> with a small error tolerance can be quite time-consuming, a hybrid strategy commonly employed consists of using a rough factorization (with e.g. large tolerance or a fixed rank) as a preconditioner to an iterative solver.</p></div></div><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="references/#HMatrices.ALLOW_GETINDEX"><code>HMatrices.ALLOW_GETINDEX</code></a></li><li><a href="references/#Base.Matrix-Tuple{HMatrix}"><code>Base.Matrix</code></a></li><li><a href="references/#HMatrices.ACA"><code>HMatrices.ACA</code></a></li><li><a href="references/#HMatrices.AbstractCompressor"><code>HMatrices.AbstractCompressor</code></a></li><li><a href="references/#HMatrices.AbstractKernelMatrix"><code>HMatrices.AbstractKernelMatrix</code></a></li><li><a href="references/#HMatrices.DHMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R}} where {R, T}"><code>HMatrices.DHMatrix</code></a></li><li><a href="references/#HMatrices.DHMatrix"><code>HMatrices.DHMatrix</code></a></li><li><a href="references/#HMatrices.HMatrix"><code>HMatrices.HMatrix</code></a></li><li><a href="references/#HMatrices.HMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R, Any}} where {R, T}"><code>HMatrices.HMatrix</code></a></li><li><a href="references/#HMatrices.HMulNode"><code>HMatrices.HMulNode</code></a></li><li><a href="references/#HMatrices.KernelMatrix"><code>HMatrices.KernelMatrix</code></a></li><li><a href="references/#HMatrices.PartialACA"><code>HMatrices.PartialACA</code></a></li><li><a href="references/#HMatrices.PermutedMatrix"><code>HMatrices.PermutedMatrix</code></a></li><li><a href="references/#HMatrices.RemoteHMatrix"><code>HMatrices.RemoteHMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Union{Tuple{V}, Tuple{Vector{V}, Vector{V}}} where V&lt;:(AbstractVector{T} where T)"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Tuple{LinearAlgebra.SVD}"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Tuple{Matrix{T} where T}"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.StrongAdmissibilityStd"><code>HMatrices.StrongAdmissibilityStd</code></a></li><li><a href="references/#HMatrices.TSVD"><code>HMatrices.TSVD</code></a></li><li><a href="references/#HMatrices.WeakAdmissibilityStd"><code>HMatrices.WeakAdmissibilityStd</code></a></li><li><a href="references/#Base.hcat-Union{Tuple{T}, Tuple{HMatrices.RkMatrix{T}, HMatrices.RkMatrix{T}}} where T"><code>Base.hcat</code></a></li><li><a href="references/#Base.vcat-Union{Tuple{T}, Tuple{HMatrices.RkMatrix{T}, HMatrices.RkMatrix{T}}} where T"><code>Base.vcat</code></a></li><li><a href="references/#HMatrices._aca_full!-NTuple{4, Any}"><code>HMatrices._aca_full!</code></a></li><li><a href="references/#HMatrices._aca_full_pivot-Tuple{Any}"><code>HMatrices._aca_full_pivot</code></a></li><li><a href="references/#HMatrices._aca_partial"><code>HMatrices._aca_partial</code></a></li><li><a href="references/#HMatrices._aca_partial_pivot-Tuple{Any, Any}"><code>HMatrices._aca_partial_pivot</code></a></li><li><a href="references/#HMatrices._assemble_cpu!-Tuple{Any, Any, Any}"><code>HMatrices._assemble_cpu!</code></a></li><li><a href="references/#HMatrices._assemble_hmat_distributed-Tuple{Any, Any, Any}"><code>HMatrices._assemble_hmat_distributed</code></a></li><li><a href="references/#HMatrices._assemble_threads!-Tuple{Any, Any, Any}"><code>HMatrices._assemble_threads!</code></a></li><li><a href="references/#HMatrices._build_block_structure!-Union{Tuple{T}, Tuple{R}, Tuple{Any, HMatrix{R, T}}} where {R, T}"><code>HMatrices._build_block_structure!</code></a></li><li><a href="references/#HMatrices._cost_gemv-Tuple{HMatrices.RkMatrix}"><code>HMatrices._cost_gemv</code></a></li><li><a href="references/#HMatrices._hgemv_recursive!-Tuple{AbstractVector{T} where T, Union{HMatrix, LinearAlgebra.Adjoint{var&quot;#s157&quot;, var&quot;#s156&quot;} where {var&quot;#s157&quot;, var&quot;#s156&quot;&lt;:HMatrix}}, AbstractVector{T} where T, Any}"><code>HMatrices._hgemv_recursive!</code></a></li><li><a href="references/#HMatrices._update_frob_norm-Tuple{Any, Any, Any}"><code>HMatrices._update_frob_norm</code></a></li><li><a href="references/#HMatrices.assemble_hmat-Tuple{Any, Any, Any}"><code>HMatrices.assemble_hmat</code></a></li><li><a href="references/#HMatrices.build_sequence_partition-NTuple{4, Any}"><code>HMatrices.build_sequence_partition</code></a></li><li><a href="references/#HMatrices.compress!-Tuple{Matrix{T} where T, TSVD}"><code>HMatrices.compress!</code></a></li><li><a href="references/#HMatrices.compress!-Tuple{HMatrices.RkMatrix, TSVD}"><code>HMatrices.compress!</code></a></li><li><a href="references/#HMatrices.compression_ratio-Tuple{HMatrices.RkMatrix}"><code>HMatrices.compression_ratio</code></a></li><li><a href="references/#HMatrices.compression_ratio-Tuple{HMatrix}"><code>HMatrices.compression_ratio</code></a></li><li><a href="references/#HMatrices.disable_getindex-Tuple{}"><code>HMatrices.disable_getindex</code></a></li><li><a href="references/#HMatrices.enable_getindex-Tuple{}"><code>HMatrices.enable_getindex</code></a></li><li><a href="references/#HMatrices.find_optimal_cost"><code>HMatrices.find_optimal_cost</code></a></li><li><a href="references/#HMatrices.find_optimal_partition"><code>HMatrices.find_optimal_partition</code></a></li><li><a href="references/#HMatrices.flush_to_children!-Tuple{HMatrix}"><code>HMatrices.flush_to_children!</code></a></li><li><a href="references/#HMatrices.flush_to_leaves!-Tuple{HMatrix}"><code>HMatrices.flush_to_leaves!</code></a></li><li><a href="references/#HMatrices.getcol-Tuple{HMatrices.RkMatrix, Int64}"><code>HMatrices.getcol</code></a></li><li><a href="references/#HMatrices.getcol!-Tuple{Any, HMatrices.RkMatrix, Int64}"><code>HMatrices.getcol!</code></a></li><li><a href="references/#HMatrices.has_partition"><code>HMatrices.has_partition</code></a></li><li><a href="references/#HMatrices.hilbert_cartesian_to_linear-Tuple{Integer, Any, Any}"><code>HMatrices.hilbert_cartesian_to_linear</code></a></li><li><a href="references/#HMatrices.hilbert_linear_to_cartesian-Tuple{Integer, Any}"><code>HMatrices.hilbert_linear_to_cartesian</code></a></li><li><a href="references/#HMatrices.hilbert_partitioning-Tuple{HMatrix, Any, Any}"><code>HMatrices.hilbert_partitioning</code></a></li><li><a href="references/#HMatrices.hmul!-Tuple{HMatrix, HMatrix, HMatrix, Any, Any, Any}"><code>HMatrices.hmul!</code></a></li><li><a href="references/#HMatrices.isclean-Tuple{HMatrix}"><code>HMatrices.isclean</code></a></li><li><a href="references/#HMatrices.num_stored_elements-Tuple{HMatrices.RkMatrix}"><code>HMatrices.num_stored_elements</code></a></li><li><a href="references/#LinearAlgebra.axpy!-Tuple{Any, Matrix{T} where T, HMatrices.RkMatrix}"><code>LinearAlgebra.axpy!</code></a></li><li><a href="references/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any, N} where N}"><code>LinearAlgebra.lu</code></a></li><li><a href="references/#LinearAlgebra.lu!-Tuple{HMatrix}"><code>LinearAlgebra.lu!</code></a></li><li><a href="references/#LinearAlgebra.lu!-Tuple{HMatrix, Any}"><code>LinearAlgebra.lu!</code></a></li><li><a href="references/#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a></li><li><a href="references/#HMatrices.@hprofile-Tuple{Any}"><code>HMatrices.@hprofile</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="kernelmatrix/">Kernel matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 13 November 2021 13:42">Saturday 13 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
