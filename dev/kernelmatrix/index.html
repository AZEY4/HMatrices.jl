<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kernel matrices · HMatrices.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://WaveProp.github.io/HMatrices.jl/kernelmatrix/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HMatrices.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li class="is-active"><a class="tocitem" href>Kernel matrices</a><ul class="internal"><li><a class="tocitem" href="#Support-for-tensor-kernels"><span>Support for tensor kernels</span></a></li><li><a class="tocitem" href="#Vectorized-kernels-and-local-indices"><span>Vectorized kernels and local indices</span></a></li></ul></li><li><a class="tocitem" href="../dhmatrix/">Distributed HMatrix</a></li><li><a class="tocitem" href="../notebooks/">Notebooks</a></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="../benchs/">Benchmark Report for <em>HMatrices</em></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Kernel matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kernel matrices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/HMatrices.jl/blob/main/docs/src/kernelmatrix.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="kernelmatrix-section"><a class="docs-heading-anchor" href="#kernelmatrix-section">Kernel matrices</a><a id="kernelmatrix-section-1"></a><a class="docs-heading-anchor-permalink" href="#kernelmatrix-section" title="Permalink"></a></h1><p>While in the <a href="../#assemble-generic-subsection">introduction</a> we presented a somewhat general way to assemble an <code>HMatrix</code>, abstract matrices associated with an underlying kernel function are common enough in boundary integral equations that a special interface exists for facilitating their use.</p><p>The <a href="../references/#HMatrices.AbstractKernelMatrix"><code>AbstractKernelMatrix</code></a> interface is used to represent matrices <code>K</code> with <code>i,j</code> entry given by <code>f(X[i],Y[j])</code>, where <code>X=rowelements(K)</code> and <code>Y=colelements(K)</code>. The row and columns elements may be as simple as points in <span>$\mathbb{R}^d$</span> (as is the case for Nyström methods), but they can also be more complex objects such as triangles or basis functions –- the only thing required is that <code>f(X[i],Y[j])</code> make sense. </p><p>A concrete implementation of <code>AbstractKernelMatrix</code> is provided by the <code>KernelMatrix</code> type. Creating the matrix associated with the Helmholtz free-space Greens function, for example, can be accomplished through:</p><pre><code class="language-julia hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point3D = SVector{3,Float64}
X = rand(Point3D,10_000)
Y = rand(Point3D,10_000)
const k = 2π
function G(x,y)
    d = norm(x-y)
    exp(im*k*d)/(4π*d)
end
K = KernelMatrix(G,X,Y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000×10000 KernelMatrix{typeof(Main.var&quot;Main&quot;.G), Vector{StaticArraysCore.SVector{3, Float64}}, Vector{StaticArraysCore.SVector{3, Float64}}, ComplexF64}:
  -0.165348+0.025494im     0.0791607-0.028907im   …   0.0787417+0.00445719im
 0.00138916-0.105799im     -0.060944-0.102992im       -0.022775-0.108609im
 0.00259852-0.10552im      0.0489936-0.0816043im      0.0396815-0.0889836im
  0.0232188+0.332293im    -0.0956483-0.0865132im      0.0673597-0.0596103im
  -0.111253-0.0746222im   -0.0822711-0.0943132im      -0.119622-0.0667225im
 -0.0760016+0.25831im      0.0233947-0.0983492im  …   0.0730456-0.0487058im
  -0.117029-0.0693011im   -0.0562556-0.104343im        0.011565-0.102997im
  -0.168254+0.0599408im   -0.0923841-0.0886027im      0.0793585-0.0277995im
 -0.0103938-0.107812im     0.0700275+0.356356im       -0.122378+0.202283im
  -0.145348+0.161006im    -0.0341295-0.108205im       0.0549049-0.0758714im
           ⋮                                      ⋱  
  -0.163601+0.0165663im    -0.094978+0.238126im      -0.0767827-0.0969624im
  -0.129563-0.0555645im   -0.0182921-0.108472im       0.0615432-0.068101im
 -0.0105093-0.107826im     -0.159247+0.123262im       -0.167943+0.04865im
  -0.167571+0.0773297im   -0.0715646-0.0992067im      0.0555166-0.075221im
 -0.0918503-0.0889325im   -0.0959067-0.0863424im  …   -0.134067-0.0497219im
   -0.15993+0.120801im     -0.162204+0.010673im       -0.152814-0.0169437im
  -0.158396-0.00233127im   -0.155397-0.0106525im      -0.135188-0.0481771im
  -0.154355+0.138673im     -0.167777+0.045927im      0.00298175-0.105428im
  -0.127312+0.194597im     0.0749036-0.0441523im      0.0699047+0.0274574im</code></pre><p>Compressing <code>K</code> is now as simple as:</p><pre><code class="language-julia hljs">H = assemble_hmat(K;rtol=1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HMatrix of ComplexF64 with range 1:10000 × 1:10000
	 number of nodes in tree: 16713
	 number of leaves: 12535 (2447 admissible + 10088 full)
	 min rank of sparse blocks : 77
	 max rank of sparse blocks : 625
	 min length of dense blocks : 1521
	 max length of dense blocks : 1600
	 min number of elements per leaf: 1521
	 max number of elements per leaf: 390625
	 depth of tree: 8
	 compression ratio: 0.544544
</code></pre><p>It is worth noting that several <em>default</em> choices are made during the compression above. See the <a href="../#assemble-generic-subsection">Assembling and <code>HMatrix</code></a> section or the documentation of <a href="@ref"><code>assemble_hmat</code></a> for information on how to obtain a more granular control of the assembling stage.</p><p>As before, you can multiply <code>H</code> by a vector, or do an <code>lu</code> factorization of it.</p><h2 id="Support-for-tensor-kernels"><a class="docs-heading-anchor" href="#Support-for-tensor-kernels">Support for tensor kernels</a><a id="Support-for-tensor-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Support-for-tensor-kernels" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Support for tensor-valued kernels should be considered experimental at this stage.</p></div></div><p>For vector-valued partial differential equations such as <em>Stokes</em> or time-harmonic <em>Maxwell&#39;s</em> equation, the underlying integral operator has a kernel function which is a tensor. This package currently provides some limited support for these types of operators. The example below illustrates how to build an <a href="../references/#HMatrices.HMatrix"><code>HMatrix</code></a> representing a <a href="../references/#HMatrices.KernelMatrix"><code>KernelMatrix</code></a> corresponding to Stokes Greens function for points on a sphere:</p><pre><code class="language-julia hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point3D = SVector{3,Float64}
m = 5_000
X = Y = [Point3D(sin(θ)cos(ϕ),sin(θ)*sin(ϕ),cos(θ)) for (θ,ϕ) in zip(π*rand(m),2π*rand(m))]
const μ = 5
function G(x,y)
    r = x-y
    d = norm(r) + 1e-10
    1/(8π*μ) * (1/d*I + r*transpose(r)/d^3)
end
K = KernelMatrix(G,X,Y)
H = assemble_hmat(K;atol=1e-4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HMatrix of StaticArraysCore.SMatrix{3, 3, Float64, 9} with range 1:5000 × 1:5000
	 number of nodes in tree: 4725
	 number of leaves: 3544 (1272 admissible + 2272 full)
	 min rank of sparse blocks : 70
	 max rank of sparse blocks : 312
	 min length of dense blocks : 1521
	 max length of dense blocks : 1600
	 min number of elements per leaf: 1521
	 max number of elements per leaf: 97656
	 depth of tree: 7
	 compression ratio: 0.544244
</code></pre><p>You can now multiply <code>H</code> by a density <code>σ</code>, where <code>σ</code> is a <code>Vector</code> of <code>SVector{3,Float64}</code></p><pre><code class="language-julia hljs">σ = rand(SVector{3,Float64},m)
y = H*σ
# test the output agains the exact value for a given `i`
i = 42
y[i] - sum(K[i,j]*σ[j] for j in 1:m)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
  35.30580997467041
 -27.472488909959793
  25.338367123156786</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <em>naive</em> idea of reinterpreting these <em>matrices of tensors</em> as a (larger) matrix of scalars does not always work because care to be taken when choosing the pivot in the compression stage of the <a href="../references/#HMatrices.PartialACA"><code>PartialACA</code></a> in order to exploit some analytic properties of the underlying kernel. See e.g. section 2.3 of <a href="https://www.sciencedirect.com/science/article/pii/S0021999117306721">this paper</a> for a brief discussion.</p></div></div><h2 id="Vectorized-kernels-and-local-indices"><a class="docs-heading-anchor" href="#Vectorized-kernels-and-local-indices">Vectorized kernels and local indices</a><a id="Vectorized-kernels-and-local-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Vectorized-kernels-and-local-indices" title="Permalink"></a></h2><p>A more efficient implementation of your kernel <code>K::AbstractKernelMatrix</code> can sometimes lead to faster <em>assembling</em> times. In particular, providing a permuted kernel <code>Kp</code> using the local indexing system of the <code>HMatrix</code> (and setting the keyword argument <code>global_index=false</code> in <code>assemble_hmat</code>) avoids frequent unnecessary index permutations, and can facilitate vectorization. This is because the permuted kernel <code>Kp</code> will be called through <code>Kp[I::UnitRange,J::UnitRange]</code> to fill in the dense blocks of the matrix, through <code>Kp[I::UnitRange,j::int]</code> and <code>adjoint(Kp)[I::UnitRange,j]</code> to build a low-rank approximation of compressible blocks. </p><p>The vectorization example in the <a href="../notebooks/#notebook-section">Notebook section</a> shows how a custom (and somewhat more complex) implementation of a vectorized Laplace kernel using the <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization</a> package can lead to faster (sequential) execution.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting started</a><a class="docs-footer-nextpage" href="../dhmatrix/">Distributed HMatrix »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 12 July 2023 12:22">Wednesday 12 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
