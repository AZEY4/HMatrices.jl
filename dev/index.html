<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · HMatrices.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://WaveProp.github.io/HMatrices.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>HMatrices.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#assemble-generic-subsection"><span>Assembling an <code>HMatrix</code></span></a></li><li><a class="tocitem" href="#Matrix-vector-product-and-iterative-solvers"><span>Matrix vector product and iterative solvers</span></a></li><li><a class="tocitem" href="#Factorization-and-direct-solvers"><span>Factorization and direct solvers</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="kernelmatrix/">Kernel matrices</a></li><li><a class="tocitem" href="dhmatrix/">Distributed HMatrix</a></li><li><a class="tocitem" href="notebooks/">Notebooks</a></li><li><span class="tocitem">Benchmarks</span><ul><li><a class="tocitem" href="benchs_v0.1.0/">Benchmark Report for <em>HMatrices</em></a></li><li><a class="tocitem" href="benchs_v0.1.1/">Benchmark Report for <em>HMatrices</em></a></li><li><a class="tocitem" href="benchs_v0.1.2/">Benchmark Report for <em>HMatrices</em></a></li></ul></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/HMatrices.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="home-section"><a class="docs-heading-anchor" href="#home-section">HMatrices.jl</a><a id="home-section-1"></a><a class="docs-heading-anchor-permalink" href="#home-section" title="Permalink"></a></h1><p><em>A package for assembling and factoring hierarchical matrices</em></p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This package provides some functionality for assembling as well as for doing linear algebra with <a href="https://en.wikipedia.org/wiki/Hierarchical_matrix">hierarchical matrices</a>. The main structure exported is the <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a> type, which can be used to efficiently approximate certain linear operators containing a hierarchical low-rank structure. Once assembled, a hierarchical matrix can be used to accelerate the solution of <code>Ax=b</code> in a variety of ways. Below you will find a quick introduction for how to <em>assemble</em> and <em>utilize</em> an <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a>; see the <a href="references/#references-section">References</a> section for more information on the available methods and structures.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Although hierarchical matrices have a broad range of application, this package focuses on their use to approximate integral operators arising in <strong>boundary integral equation (BIE)</strong> methods. As such, most of the API has been designed with BIEs in mind, and the examples that follow will focus on the compression of integral operators. Feel free to open an <a href="https://github.com/WaveProp/HMatrices.jl/issues/new">issue</a> or reach out if you have an interesting application of hierarchical matrices in mind not covered by this package!</p></div></div><div class="admonition is-success"><header class="admonition-header">Useful references</header><div class="admonition-body"><p>The notation and algorithms implemented were mostly drawn from the following references:</p><ul><li>Hackbusch, Wolfgang. <em>Hierarchical matrices: algorithms and analysis</em>. Vol. 49. Heidelberg: Springer, 2015.</li><li>Bebendorf, Mario. <em>Hierarchical matrices</em>. Springer Berlin Heidelberg, 2008.</li></ul></div></div><h2 id="assemble-generic-subsection"><a class="docs-heading-anchor" href="#assemble-generic-subsection">Assembling an <code>HMatrix</code></a><a id="assemble-generic-subsection-1"></a><a class="docs-heading-anchor-permalink" href="#assemble-generic-subsection" title="Permalink"></a></h2><p>In order to assemble an <a href="references/#HMatrices.HMatrix"><code>HMatrix</code></a>, you need the following (problem-specific) ingredients:</p><ol><li>The matrix-like object <code>K</code> that you wish to compress</li><li>A <code>rowtree</code> and <code>coltree</code> providing a hierarchical partition of the rows and columns of <code>K</code></li><li>An admissibility condition for determining (<em>a priory</em>) whether a block given by a node in the <code>rowtree</code> and node in the <code>coltree</code> is compressible</li><li>A function/functor to generate a low-rank approximation of compressible blocks</li></ol><p>To illustrate how this is done for a concrete problem, consider two set of points <span>$X = \left\{ \boldsymbol{x}_i \right\}_{i=1}^m$</span> and <span>$Y =\left\{\boldsymbol{x}_j \right\}_{j=1}^n$</span> in <span>$\mathbb{R}^3$</span>, and let <code>K</code> be a  <span>$m \times n$</span> matrix with entries given by:</p><p class="math-container">\[  K_{i,j} = G(\boldsymbol{x}_i,\boldsymbol{y}_j)\]</p><p>for some kernel function <span>$G$</span>. To make things simple, we will take <span>$X$</span> and <span>$Y$</span> to be points distributed on a circle:</p><pre><code class="language-julia hljs">using HMatrices, LinearAlgebra, StaticArrays
const Point2D = SVector{2,Float64}

# points on a circle
m = n = 10_000
X = Y = [Point2D(sin(i*2π/n),cos(i*2π/n)) for i in 0:n-1]
nothing</code></pre><p>Next we will create the matrix-like structure to represent the object <code>K</code>. We will pick <code>G</code> to be the free-space Greens function for Laplace&#39;s equation in two-dimensions:</p><pre><code class="language-julia hljs">struct LaplaceMatrix &lt;: AbstractMatrix{Float64}
  X::Vector{Point2D}
  Y::Vector{Point2D}
end

Base.getindex(K::LaplaceMatrix,i::Int,j::Int) = -1/2π*log(norm(K.X[i] - K.Y[j]) + 1e-10)
Base.size(K::LaplaceMatrix) = length(K.X), length(K.Y)

# create the abstract matrix
K = LaplaceMatrix(X,Y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000×10000 Main.LaplaceMatrix:
 3.66468   1.17336   1.06305   0.998514  …  0.998514  1.06305   1.17336
 1.17336   3.66468   1.17336   1.06305      0.952728  0.998514  1.06305
 1.06305   1.17336   3.66468   1.17336      0.917214  0.952728  0.998514
 0.998514  1.06305   1.17336   3.66468      0.888197  0.917214  0.952728
 0.952728  0.998514  1.06305   1.17336      0.863663  0.888197  0.917214
 0.917214  0.952728  0.998514  1.06305   …  0.842411  0.863663  0.888197
 0.888197  0.917214  0.952728  0.998514     0.823665  0.842411  0.863663
 0.863663  0.888197  0.917214  0.952728     0.806896  0.823665  0.842411
 0.842411  0.863663  0.888197  0.917214     0.791727  0.806896  0.823665
 0.823665  0.842411  0.863663  0.888197     0.777879  0.791727  0.806896
 ⋮                                       ⋱                      
 0.823665  0.806896  0.791727  0.777879     0.888197  0.863663  0.842411
 0.842411  0.823665  0.806896  0.791727     0.917214  0.888197  0.863663
 0.863663  0.842411  0.823665  0.806896     0.952728  0.917214  0.888197
 0.888197  0.863663  0.842411  0.823665     0.998514  0.952728  0.917214
 0.917214  0.888197  0.863663  0.842411  …  1.06305   0.998514  0.952728
 0.952728  0.917214  0.888197  0.863663     1.17336   1.06305   0.998514
 0.998514  0.952728  0.917214  0.888197     3.66468   1.17336   1.06305
 1.06305   0.998514  0.952728  0.917214     1.17336   3.66468   1.17336
 1.17336   1.06305   0.998514  0.952728     1.06305   1.17336   3.66468</code></pre><p>The next step consists in partitioning the point clouds <code>X</code> and <code>Y</code> into a tree-like data structure so that blocks corresponding to well-separated points can be easily distinguished and compressed. The <code>WavePropBase</code> package provides the <code>ClusterTree</code> struct for this purpose (see its documentation for more details on available options):</p><pre><code class="language-julia hljs">Xclt = Yclt = ClusterTree(X)</code></pre><p>The object <code>Xclt</code> represents a tree partition of the point cloud into axis-aligned bounding boxes.</p><p>The third requirement is an <em>admissibilty condition</em> to determine if the interaction between two clusters should be compressed. We will use the <a href="references/#HMatrices.StrongAdmissibilityStd"><code>StrongAdmissibilityStd</code></a>, which is appropriate for <em>asymptotically smooth kernels</em> such as the one considered:</p><pre><code class="language-julia hljs">adm = StrongAdmissibilityStd()</code></pre><p>The final step is to provide a method to compress admissible blocks. Here we will use the <a href="references/#HMatrices.PartialACA"><code>PartialACA</code></a> functor implementing an <em>adaptive cross approximation</em> with partial pivoting strategy:</p><pre><code class="language-julia hljs">comp = PartialACA(;atol=1e-6)</code></pre><p>With these ingredients at hand, we can assemble an approximation for <code>K</code> using</p><pre><code class="language-julia hljs">H = assemble_hmat(K,Xclt,Yclt;adm,comp,threads=false,distributed=false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HMatrix of Float64 with range 1:10000 × 1:10000
	 number of nodes in tree: 3061
	 number of leaves: 2296 (760 admissible + 1536 full)
	 min rank of sparse blocks : 5
	 max rank of sparse blocks : 7
	 min length of dense blocks : 1521
	 max length of dense blocks : 1600
	 min number of elements per leaf: 1521
	 max number of elements per leaf: 1562500
	 depth of tree: 8
	 compression ratio: 22.916007
</code></pre><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>The <a href="references/#HMatrices.assemble_hmat-Tuple{Any, Any, Any}"><code>assemble_hmat</code></a> function is the main constructor exported by this package, so it is worth getting familiar with it and the various keyword arguments it accepts.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Reasonable defaults exist for the <em>admissibility condition</em>, <em>cluster tree</em>, and <em>compressor</em> when the kernel <code>K</code> is an <a href="references/#HMatrices.AbstractKernelMatrix"><code>AbstractKernelMatrix</code></a>, so that the construction process is somewhat simpler than just presented in those cases. Manually constructing each ingredient, however, gives a level of control not available through the default constructors. See the <a href="kernelmatrix/#kernelmatrix-section">Kernel matrices section</a> for more details.</p></div></div><p>You can now use <code>H</code> <em>in lieu</em> of <code>K</code> (as an approximation) for certain linear algebra operations, as shown next.</p><div class="admonition is-success"><header class="admonition-header">Disabling `getindex`</header><div class="admonition-body"><p>Although the <code>getindex(H,i::Int,j::Int)</code> method is defined for an <code>AbstractHMatrix</code>, its use is mostly for display purposes in a <code>REPL</code> environment, and should be avoided in any linear algebra routine. To avoid the performance pitfalls related to methods falling back to the generic <code>LinearAlgebra</code> implementation of various algorithms (which make use <code>getindex</code> extensively), you can disable <code>getindex</code> on types defined in this package by calling <a href="references/#HMatrices.disable_getindex-Tuple{}"><code>HMatrices.disable_getindex</code></a>. The consequence is that calling <code>getindex(H,i,j)</code> will throw an error. If a given operation is running unexpectedly slow, try disabling <code>getindex</code> to see if any part of the code is falling back to a generic implementation.</p></div></div><h2 id="Matrix-vector-product-and-iterative-solvers"><a class="docs-heading-anchor" href="#Matrix-vector-product-and-iterative-solvers">Matrix vector product and iterative solvers</a><a id="Matrix-vector-product-and-iterative-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-vector-product-and-iterative-solvers" title="Permalink"></a></h2><p>The simplest operation you can perform with an <code>HMatrix</code> is to multiply it by a vector:</p><pre><code class="language-julia hljs">x = rand(n)
norm(H*x - K*x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.781194572640623e-7</code></pre><p>More advanced options (such as choosing between a threaded or serial implementation) can be accessed by calling <a href="references/#LinearAlgebra.mul!"><code>mul!</code></a> directly:</p><pre><code class="language-julia hljs">y = similar(x)
mul!(y,H,x,1,0;threads=false)
norm(y - K*x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7.781194903958262e-7</code></pre><p>The example below illustrates how to use the <code>HMatrix</code> <code>H</code> constructed above with the <a href="https://github.com/JuliaLinearAlgebra/IterativeSolvers.jl"><code>IterativeSolvers</code></a> package:</p><pre><code class="language-julia hljs">using IterativeSolvers
b = rand(m)
approx = gmres!(y,H,b;abstol=1e-6)
exact  = Matrix(K)\b
norm(approx-exact)/norm(exact)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6.740423809157682e-5</code></pre><p>Internally, the hierarchical matrix <code>H</code> is stored as <code>H = inv(Pr)*_H*Pc</code>, where <code>Pr</code> and <code>Pc</code> are row and column permutation matrices induced by the clustering of the target and source points as <code>ClusterTree</code>s, respectively, and <code>_H</code> is the actual hierarchical matrix constructed. It is sometimes convenient to work directly with <code>_H</code> for performance reasons; for example, in the iterative solver above, you may want to permute rows and columns only once <em>offline</em> and perform the matrix multiplication with <code>_H</code>. The keyword argument <code>global_index=false</code> can be passed to perform the desired operations on <code>_H</code> instead, or you may overload the <a href="references/#HMatrices.use_global_index-Tuple{}"><code>HMatrices.use_global_index</code></a> method which will in turn change the default value of <code>global_index</code> throughout the package (but be careful to know what you are doing, as this may cause some <em>unexpected</em> results); similarly, you can overload <a href="references/#HMatrices.use_threads-Tuple{}"><code>HMatrices.use_threads</code></a> to globally change whether threads are used by default. In the iterative example above, for instance, we may permute the vectors <em>externally</em> before and after (but not in each forward product) as follows:</p><pre><code class="language-julia hljs">cperm  = HMatrices.colperm(H) # column permutation
rperm  = HMatrices.rowperm(H) # row permutation
bp     = b[cperm]
HMatrices.use_global_index() = false # perform operations on the local indexing system
approx = gmres!(y,H,bp;abstol=1e-6)
invpermute!(approx,rperm)
HMatrices.use_global_index() = true # go back to default
norm(approx-exact)/norm(exact)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.1529426336507458e-8</code></pre><div class="admonition is-info"><header class="admonition-header">Problem size</header><div class="admonition-body"><p>For &quot;small&quot; problem sizes, the overhead associated with the more complex structure of an <code>HMatrix</code> will lead to computational times that are larger than the <em>dense</em> representation, even when the <code>HMatrix</code> occupies less memory. For large problem sizes, however, the loglinear complexity will yield significant gains in terms of memory and cpu time provided the underlying operator has a hierarchical low-rank structure.</p></div></div><h2 id="Factorization-and-direct-solvers"><a class="docs-heading-anchor" href="#Factorization-and-direct-solvers">Factorization and direct solvers</a><a id="Factorization-and-direct-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Factorization-and-direct-solvers" title="Permalink"></a></h2><p>Although the forward map illustrated in the example above suffices to solve the linear system <code>Kx = b</code> using an iterative solver, there are circumstances where a <em>direct</em> solver is desirable (because, e.g., the system is not well-conditioned or you wish to solve it for many right-hand-sides <code>b</code>). At present, the only available factorization is the <strong>hierarchical lu</strong> factorization of <code>H</code>, which can be accomplished as follows:</p><pre><code class="language-julia hljs">F = lu(H;atol=1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearAlgebra.LU{Float64, HMatrix{ClusterTree{Vector{StaticArrays.SVector{2, Float64}}, HyperRectangle{2, Float64}, Nothing}, Float64}}
L factor:
10000×10000 LinearAlgebra.UnitLowerTriangular{Float64, HMatrix{ClusterTree{Vector{StaticArrays.SVector{2, Float64}}, HyperRectangle{2, Float64}, Nothing}, Float64}}:
  1.0          ⋅           ⋅         …   ⋅          ⋅          ⋅         ⋅ 
  0.320182    1.0          ⋅             ⋅          ⋅          ⋅         ⋅ 
  0.290079    0.253268    1.0            ⋅          ⋅          ⋅         ⋅ 
  0.27247     0.226009    0.221105       ⋅          ⋅          ⋅         ⋅ 
  0.259976    0.210845    0.19427        ⋅          ⋅          ⋅         ⋅ 
  0.250285    0.200382    0.1798     …   ⋅          ⋅          ⋅         ⋅ 
  0.242367    0.192409    0.170031       ⋅          ⋅          ⋅         ⋅ 
  0.235672    0.185974    0.162707       ⋅          ⋅          ⋅         ⋅ 
  0.229873    0.180584    0.156869       ⋅          ⋅          ⋅         ⋅ 
  0.224758    0.175947    0.152025       ⋅          ⋅          ⋅         ⋅ 
  ⋮                                  ⋱                                  
 -0.0301011  -0.0228008  -0.0188596      ⋅          ⋅          ⋅         ⋅ 
 -0.0301009  -0.0228007  -0.0188595      ⋅          ⋅          ⋅         ⋅ 
 -0.0301008  -0.0228006  -0.0188594      ⋅          ⋅          ⋅         ⋅ 
 -0.0301007  -0.0228005  -0.0188594      ⋅          ⋅          ⋅         ⋅ 
 -0.0301005  -0.0228004  -0.0188593  …   ⋅          ⋅          ⋅         ⋅ 
 -0.0301004  -0.0228003  -0.0188592     1.0         ⋅          ⋅         ⋅ 
 -0.0301002  -0.0228002  -0.0188591     0.122216   1.0         ⋅         ⋅ 
 -0.0301001  -0.0228001  -0.018859      0.0861291  0.117223   1.0        ⋅ 
 -0.0300999  -0.0228     -0.0188589     0.063447   0.0786916  0.108672  1.0
U factor:
10000×10000 LinearAlgebra.UpperTriangular{Float64, HMatrix{ClusterTree{Vector{StaticArrays.SVector{2, Float64}}, HyperRectangle{2, Float64}, Nothing}, Float64}}:
 3.66468  1.17336  1.06305   0.998514  …  -0.110308   -0.110307   -0.110306
  ⋅       3.28899  0.832996  0.74334      -0.0749897  -0.0749893  -0.0749889
  ⋅        ⋅       3.14534   0.695452     -0.0593183  -0.059318   -0.0593177
  ⋅        ⋅        ⋅        3.07084      -0.0501898  -0.0501896  -0.0501894
  ⋅        ⋅        ⋅         ⋅           -0.0441324  -0.0441323  -0.0441321
  ⋅        ⋅        ⋅         ⋅        …  -0.0397849  -0.0397847  -0.0397846
  ⋅        ⋅        ⋅         ⋅           -0.0364948  -0.0364947  -0.0364946
  ⋅        ⋅        ⋅         ⋅           -0.0339079  -0.0339078  -0.0339077
  ⋅        ⋅        ⋅         ⋅           -0.0318139  -0.0318138  -0.0318137
  ⋅        ⋅        ⋅         ⋅           -0.0300795  -0.0300795  -0.0300794
 ⋮                                     ⋱                          
  ⋅        ⋅        ⋅         ⋅            0.142471    0.120271    0.0980492
  ⋅        ⋅        ⋅         ⋅            0.158864    0.132654    0.107231
  ⋅        ⋅        ⋅         ⋅            0.180351    0.1483      0.118532
  ⋅        ⋅        ⋅         ⋅            0.210269    0.168907    0.132877
  ⋅        ⋅        ⋅         ⋅        …   0.256358    0.197772    0.151879
  ⋅        ⋅        ⋅         ⋅            0.344208    0.242573    0.178692
  ⋅        ⋅        ⋅         ⋅            2.80505     0.328818    0.220734
  ⋅        ⋅        ⋅         ⋅             ⋅          2.78768     0.302942
  ⋅        ⋅        ⋅         ⋅             ⋅           ⋅          2.75476</code></pre><p>Note that unliked the matrix-vector product, factoring <code>H</code> is not <em>exact</em> in the sense that <code>lu(H) ≠ lu(Matrix(H))</code>. The accuracy of the approximation can be controlled through the keyword arguments <code>atol,rol</code> and <code>rank</code>, which are used in the various intermediate truncations performed during the factorization. See <a href="references/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any}}"><code>lu</code></a> for more details.</p><div class="admonition is-category-important"><header class="admonition-header">Truncation error</header><div class="admonition-body"><p>The parameters <code>atol</code> and <code>rtol</code> are used to control the truncation of low-rank blocks <em>adaptively</em> using an estimate of the true error (in Frobenius norm). These local errors may accumulate after successive truncations, meaning that the global approximation error (in Frobenius norm) may be larger than the prescribed tolerance.</p></div></div><p>The returned object <code>F</code> is of the <code>LU</code> type, and efficient routines are provided to solve linear system using <code>F</code>:</p><pre><code class="language-julia hljs">approx = F\b
norm(approx-exact)/norm(exact)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.1921454990108466e-8</code></pre><p>Note that the error in solving the linear system may be significantly larger than the error in computing <code>H*x</code> due to the condition of the underlying operator.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Because factoring an <code>HMatrix</code> with a small error tolerance can be quite time-consuming, a hybrid strategy commonly employed consists of using a rough factorization (with e.g. large tolerance or a fixed rank) as a preconditioner to an iterative solver.</p></div></div><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="references/#HMatrices.ALLOW_GETINDEX"><code>HMatrices.ALLOW_GETINDEX</code></a></li><li><a href="references/#HMatrices.CACHED_PARTITIONS"><code>HMatrices.CACHED_PARTITIONS</code></a></li><li><a href="references/#Base.Matrix-Tuple{HMatrix}"><code>Base.Matrix</code></a></li><li><a href="references/#HMatrices.ACA"><code>HMatrices.ACA</code></a></li><li><a href="references/#HMatrices.AbstractCompressor"><code>HMatrices.AbstractCompressor</code></a></li><li><a href="references/#HMatrices.AbstractKernelMatrix"><code>HMatrices.AbstractKernelMatrix</code></a></li><li><a href="references/#HMatrices.DHMatrix"><code>HMatrices.DHMatrix</code></a></li><li><a href="references/#HMatrices.DHMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R}} where {R, T}"><code>HMatrices.DHMatrix</code></a></li><li><a href="references/#HMatrices.HMatrix"><code>HMatrices.HMatrix</code></a></li><li><a href="references/#HMatrices.HMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R, Any}} where {R, T}"><code>HMatrices.HMatrix</code></a></li><li><a href="references/#HMatrices.HMulNode"><code>HMatrices.HMulNode</code></a></li><li><a href="references/#HMatrices.KernelMatrix"><code>HMatrices.KernelMatrix</code></a></li><li><a href="references/#HMatrices.PartialACA"><code>HMatrices.PartialACA</code></a></li><li><a href="references/#HMatrices.Partition"><code>HMatrices.Partition</code></a></li><li><a href="references/#HMatrices.PermutedMatrix"><code>HMatrices.PermutedMatrix</code></a></li><li><a href="references/#HMatrices.RemoteHMatrix"><code>HMatrices.RemoteHMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Tuple{LinearAlgebra.SVD}"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Tuple{Matrix}"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix-Union{Tuple{V}, Tuple{Vector{V}, Vector{V}}} where V&lt;:(AbstractVector)"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.RkMatrix"><code>HMatrices.RkMatrix</code></a></li><li><a href="references/#HMatrices.StrongAdmissibilityStd"><code>HMatrices.StrongAdmissibilityStd</code></a></li><li><a href="references/#HMatrices.TSVD"><code>HMatrices.TSVD</code></a></li><li><a href="references/#HMatrices.WeakAdmissibilityStd"><code>HMatrices.WeakAdmissibilityStd</code></a></li><li><a href="references/#Base.hcat-Union{Tuple{T}, Tuple{HMatrices.RkMatrix{T}, HMatrices.RkMatrix{T}}} where T"><code>Base.hcat</code></a></li><li><a href="references/#Base.vcat-Union{Tuple{T}, Tuple{HMatrices.RkMatrix{T}, HMatrices.RkMatrix{T}}} where T"><code>Base.vcat</code></a></li><li><a href="references/#HMatrices._aca_full!-NTuple{4, Any}"><code>HMatrices._aca_full!</code></a></li><li><a href="references/#HMatrices._aca_full_pivot-Tuple{Any}"><code>HMatrices._aca_full_pivot</code></a></li><li><a href="references/#HMatrices._aca_partial"><code>HMatrices._aca_partial</code></a></li><li><a href="references/#HMatrices._aca_partial_pivot-Tuple{Any, Any}"><code>HMatrices._aca_partial_pivot</code></a></li><li><a href="references/#HMatrices._assemble_cpu!-Tuple{Any, Any, Any}"><code>HMatrices._assemble_cpu!</code></a></li><li><a href="references/#HMatrices._assemble_hmat_distributed-Tuple{Any, Any, Any}"><code>HMatrices._assemble_hmat_distributed</code></a></li><li><a href="references/#HMatrices._assemble_threads!-Tuple{Any, Any, Any}"><code>HMatrices._assemble_threads!</code></a></li><li><a href="references/#HMatrices._build_block_structure!-Union{Tuple{T}, Tuple{R}, Tuple{Any, HMatrix{R, T}}} where {R, T}"><code>HMatrices._build_block_structure!</code></a></li><li><a href="references/#HMatrices._cost_gemv-Tuple{HMatrices.RkMatrix}"><code>HMatrices._cost_gemv</code></a></li><li><a href="references/#HMatrices._hgemv_recursive!-Tuple{AbstractVector, Union{HMatrix, LinearAlgebra.Adjoint{&lt;:Any, &lt;:HMatrix}}, AbstractVector, Any}"><code>HMatrices._hgemv_recursive!</code></a></li><li><a href="references/#HMatrices._update_frob_norm-Tuple{Any, Any, Any}"><code>HMatrices._update_frob_norm</code></a></li><li><a href="references/#HMatrices.assemble_hmat-Tuple{Any, Any, Any}"><code>HMatrices.assemble_hmat</code></a></li><li><a href="references/#HMatrices.build_sequence_partition-NTuple{4, Any}"><code>HMatrices.build_sequence_partition</code></a></li><li><a href="references/#HMatrices.compress!-Tuple{Matrix, TSVD}"><code>HMatrices.compress!</code></a></li><li><a href="references/#HMatrices.compress!-Tuple{HMatrices.RkMatrix, TSVD}"><code>HMatrices.compress!</code></a></li><li><a href="references/#HMatrices.compression_ratio-Tuple{HMatrices.RkMatrix}"><code>HMatrices.compression_ratio</code></a></li><li><a href="references/#HMatrices.compression_ratio-Tuple{HMatrix}"><code>HMatrices.compression_ratio</code></a></li><li><a href="references/#HMatrices.disable_getindex-Tuple{}"><code>HMatrices.disable_getindex</code></a></li><li><a href="references/#HMatrices.enable_getindex-Tuple{}"><code>HMatrices.enable_getindex</code></a></li><li><a href="references/#HMatrices.find_optimal_cost"><code>HMatrices.find_optimal_cost</code></a></li><li><a href="references/#HMatrices.find_optimal_partition"><code>HMatrices.find_optimal_partition</code></a></li><li><a href="references/#HMatrices.flush_to_children!-Tuple{HMatrix}"><code>HMatrices.flush_to_children!</code></a></li><li><a href="references/#HMatrices.flush_to_leaves!-Tuple{HMatrix}"><code>HMatrices.flush_to_leaves!</code></a></li><li><a href="references/#HMatrices.getcol-Tuple{HMatrices.RkMatrix, Int64}"><code>HMatrices.getcol</code></a></li><li><a href="references/#HMatrices.getcol!-Tuple{Any, HMatrices.RkMatrix, Int64}"><code>HMatrices.getcol!</code></a></li><li><a href="references/#HMatrices.has_partition"><code>HMatrices.has_partition</code></a></li><li><a href="references/#HMatrices.hilbert_cartesian_to_linear-Tuple{Integer, Any, Any}"><code>HMatrices.hilbert_cartesian_to_linear</code></a></li><li><a href="references/#HMatrices.hilbert_linear_to_cartesian-Tuple{Integer, Any}"><code>HMatrices.hilbert_linear_to_cartesian</code></a></li><li><a href="references/#HMatrices.hilbert_partition"><code>HMatrices.hilbert_partition</code></a></li><li><a href="references/#HMatrices.hmul!-Tuple{HMatrix, HMatrix, HMatrix, Any, Any, Any}"><code>HMatrices.hmul!</code></a></li><li><a href="references/#HMatrices.isclean-Tuple{HMatrix}"><code>HMatrices.isclean</code></a></li><li><a href="references/#HMatrices.num_stored_elements-Tuple{HMatrices.RkMatrix}"><code>HMatrices.num_stored_elements</code></a></li><li><a href="references/#HMatrices.use_global_index-Tuple{}"><code>HMatrices.use_global_index</code></a></li><li><a href="references/#HMatrices.use_threads-Tuple{}"><code>HMatrices.use_threads</code></a></li><li><a href="references/#LinearAlgebra.axpy!-Tuple{Any, Matrix, HMatrices.RkMatrix}"><code>LinearAlgebra.axpy!</code></a></li><li><a href="references/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any}}"><code>LinearAlgebra.lu</code></a></li><li><a href="references/#LinearAlgebra.lu!-Tuple{HMatrix}"><code>LinearAlgebra.lu!</code></a></li><li><a href="references/#LinearAlgebra.lu!-Tuple{HMatrix, Any}"><code>LinearAlgebra.lu!</code></a></li><li><a href="references/#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a></li><li><a href="references/#HMatrices.@hprofile-Tuple{Any}"><code>HMatrices.@hprofile</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="kernelmatrix/">Kernel matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Saturday 11 June 2022 14:09">Saturday 11 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
